오픈소스, 컨테이너 기반
AWS등 다양한 클라우드 서비스에서 지원
복잡한 리눅스 app을 컨테이너로 묶어서 실행 가능
개발과 테스트, 서비스 환경을 하나로 합쳐 효율적인 운영 가능
리눅스 커널에서 제공하는 컨테이너 기술 이용

- 가상화 
가상 머신 : 컴퓨터 안에서 컴퓨터를 생성하는 기술
여유있는 서버를 효율적이게 운영하게 하기 위해서 가상머신 기술 도입.
WAS, 데이터베이스 등을 설치하여 운영 가능. 
미리 구축한 가상 이미지를 여러 서버에 복사하여 실행하게 되면 이미지를 통해 서버를 계속 생성할 수 있다.
가상화 기술을 이용하여 서버를 임대해주는 서비스 : 클라우드 서비스
웹 호스팅 : 실제 물리적인 서버를 공유
 <-> 클라우드 서비스 : 각각의 독립적인 가상화 기술을 이용하여 가상 머신 안에서 독립적으로 실제로 컴퓨터가 운영되는, 즉 서버 환경을 구성하여 운용할 수 있도록 함
가상머신의 문제점 : 컴퓨터를 그대로 복사하여, 기존의 물리적인 컴퓨터 안에 가상의 컴퓨터를 생성하는 과정이기에 
성능적인 손실이 발생(독립적인 운영체제(Guest OS)를 생성, 이미지 안에 운영체제가 포함되어 용량이 커짐, 성능측면 문제)
-> CPU안에 가상화 기술을 넣음 -> 성능적인 측면 여전히 문제
-> 반가상화 기술 : 호스트와 커널을 공유함.

- 컨테이너 기술 : 가상화 개념에서 경량화된 기술
컨테이너 안에 가상 공간을 만들지만 실행 파일을 호스트에서 직접 실행한다.
격리(isolation)의 개념
Docker : 리눅스 컨테이너를 사용. Guest OS를 설치하지 않고 Docker image에 서버 운용을 위한 프로그램과 라이브러리만 격리하여 설치하게 된다.
이미지 용량이 크게 줄어든다. 호스트와 OS의 system call을 공유하게 된다. 하드웨어 가상화 계층이 없으며 성능이 가상화 기술에 비해 뛰어나다.
이미지 생성화 배포에 특화되었다. DevOps(운영과 서버관리)의 측면에서 큰 인기를 얻음
또한 중앙 저장소에 이미지를 올리고 내려받는 것이 가능하다.(DockerHub), 다양한 API 제공

Docker 이미지 : 서비스 운영에 필요한 서버 프로그램, 소스 코드, 컴파일된 실행파일을 묶은 형태, 저장소에 올리고(push) 받는(pull) 파일
컨테이너 : 이미지를 실행한 상태(런타임 상태), 이미지를 여러개의 컨테이너로 만들 수 있다.
이미지(실행파일), 컨테이너(프로세스)의 개념

Docker의 이미지의 바뀐 부분을 관리하는 방법 : Union file System 형식
베이스 이미지에서 바뀐 부분만 이미지로 생성, 
컨테이너로 실행할 때에는 베이스 이미지와 바뀐 부분을 합쳐서 실행
Dockerhub와 개인 저장소에서 이미지를 공유할 때 바뀐 부분만 주고받을 수 있다. 각 이미지는 의존관계를 형성하게 된다.
Docker 등장 이후 서버 운영 환경의 발전 
물리적인 서버(iDC센터)를 직접 운영, 호스팅 -> 
서버 운영의 비용, 인력이 많이 듬 -> 
가상화, 클라우드 서비스 등장, 운영하고 있는 서버가 실제로 사용하는 만큼만 비용을 지불 -> 
가상 서버를 생성, 삭제, 복제, 배포, 프로세스 관리, 로깅 등의 모든 과정이 자동화되었다. CI/CD를 통해 손쉽게 이루어지게 되었다. 코드로서의 일관성과 자동화를 보장받을 수 있게 되었다.
서버 개수가 많아져도 모든 것이 사람이 아닌 코드로서 자동화되기에 아무리 물리적인 서버나 다른 환경에서 새롭게 배포하더라도 손쉽게 DevOps환경을 운용할 수 있게 되었다.


Docker 사용
1. 버전 확인 : AWS상에서 Docker 컨테이너 배포시 호환이 가능한지 확인
- docker version : 클라이언트와 서버의 디테일한 정보
- docker -v : 도커의 버전만 확인

2. Docker은 이미지 기반
nodejs 운용환경을 가상머신에 복제하여 쉽게 운용하는 것 처럼
docker image 또한 기존의 image들을 활용할 수 있다.
- docker search node // node 키워드를 가진 이미지들을 검색
-docker node images //같은 이름을 가지고 있지만 태그가 다른 이미지들을 출력

3. pull 
만들어져 있는 image들 실제 반영될 수 있도록 한다.
-docker pull node(이미지명)
-docker pull node(이미지명):latest(버전)

4. Docker 실행
docker run --name node -d -it node:latest /bin/bash
docker run --name node(이미지명) -d(백그라운드로 실행) -it(터미널 입력을 위한 옵션) node:latest /bin/bash실행경로

docker ps -a : 현재 실행중인 모든 컨테이너를 보여주는 명령어

5. 컨테이너 중단
docker stop 50814ce88f8d(컨테이너 ID)